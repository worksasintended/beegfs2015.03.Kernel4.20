#include <common/net/message/nodes/SetMirrorBuddyGroupMsg.h>
#include <common/net/message/nodes/SetMirrorBuddyGroupRespMsg.h>
#include <common/toolkit/MessagingTk.h>
#include <common/toolkit/NodesTk.h>

#include "MirrorBuddyGroupCreator.h"


/**
 * @return FhgfsOpsErr_...
 */
FhgfsOpsErr MirrorBuddyGroupCreator::addGroup(NodeStore* mgmtNodes, uint16_t primaryTargetID,
   uint16_t secondaryTargetID, uint16_t forcedGroupID)
{
   LogContext log = LogContext("MirrorBuddyGroupCreator (addGroup)");

   FhgfsOpsErr retVal = FhgfsOpsErr_INTERNAL;

   uint16_t newGroupID;
   FhgfsOpsErr addRes = addGroupComm(mgmtNodes, primaryTargetID, secondaryTargetID, forcedGroupID,
      newGroupID);

   if (addRes != FhgfsOpsErr_SUCCESS)
   {
      std::string errStr;

      if (addRes == FhgfsOpsErr_INUSE)
         errStr = "One of the targets is already mapped to a buddy group.";
      else
      if (addRes == FhgfsOpsErr_UNKNOWNTARGET)
         errStr = FhgfsOpsErrTk::toErrString(addRes);
      else
      if (addRes == FhgfsOpsErr_EXISTS)
         errStr = "Mirror buddy group with ID " + StringTk::uintToStr(forcedGroupID)
            + " already exists.";
      else
         errStr = "Internal error.";

      std::string logMessage("Failed to add mirror buddy group: primaryTargetID " +
         StringTk::uintToStr(primaryTargetID) + "; secondaryTargetID " +
         StringTk::uintToStr(secondaryTargetID) + "; Error: " + errStr);
      std::cerr << logMessage << std::endl;
      log.logErr(logMessage);
   }
   else
   {
      std::string logMessage("Mirror buddy group successfully set: groupID " +
         StringTk::uintToStr(newGroupID) + " -> target IDs " +
         StringTk::uintToStr(primaryTargetID) + ", " + StringTk::uintToStr(secondaryTargetID) );
      std::cout << logMessage << std::endl;
      log.log(Log_NOTICE, logMessage);

      retVal = FhgfsOpsErr_SUCCESS;
   }

   return retVal;
}

/*
 * @param primaryTargetID
 * @param secondaryTargetID
 * @param forcedGroupID 0 means create new group, otherwise create group with that ID
 * @param outNewGroupID will be set by response message; will have the generated ID of a newly
 *    created group or the old group ID if a group was changed
 * @return FhgfsOpsErr_...
 */
FhgfsOpsErr MirrorBuddyGroupCreator::addGroupComm(NodeStore* mgmtNodes, uint16_t primaryTargetID,
   uint16_t secondaryTargetID, uint16_t forcedGroupID, uint16_t& outNewGroupID)
{
   FhgfsOpsErr retVal = FhgfsOpsErr_INTERNAL;

   Node* mgmtNode = mgmtNodes->referenceFirstNode();

   bool commRes;
   char* respBuf = NULL;
   NetMessage* respMsg = NULL;
   SetMirrorBuddyGroupRespMsg* respMsgCast;

   SetMirrorBuddyGroupMsg msg(primaryTargetID, secondaryTargetID, forcedGroupID, false);

   // request/response
   commRes = MessagingTk::requestResponse(
      mgmtNode, &msg, NETMSGTYPE_SetMirrorBuddyGroupResp, &respBuf, &respMsg);
   if(!commRes)
   {
      retVal = FhgfsOpsErr_COMMUNICATION;
      goto err_cleanup;
   }

   respMsgCast = (SetMirrorBuddyGroupRespMsg*)respMsg;

   retVal = (FhgfsOpsErr)respMsgCast->getResult();

   if (forcedGroupID != 0)
      outNewGroupID = forcedGroupID;
   else
      outNewGroupID = respMsgCast->getBuddyGroupID();

err_cleanup:
   mgmtNodes->releaseNode(&mgmtNode);
   SAFE_DELETE(respMsg);
   SAFE_FREE(respBuf);

   return retVal;
}

/**
 * Create all MirrorBuddyGroups which was generated by the automatic mode
 *
 * @param mgmtNodes NodeStore with the management nodes
 * @param retValGeneration the return value of the MirrorBuddyGroup generation
 * @param doForce true if the creation of the MirrorBuddyGroups is forced
 * @param doDryrun if true only select MirrorBuddyGroups and print them but do not create them
 * @param buddyGroupIDs A list with all MirrorBuddyGroupIDs to create
 * @param buddyGroups A list with all MirrorBuddyGroups to create
 * @return true if all MirrorBuddyGroups created successful, false if not
 */
bool MirrorBuddyGroupCreator::createMirrorBuddyGroups(NodeStore* mgmtNodes,
   FhgfsOpsErr retValGeneration, bool doForce, bool doDryrun, UInt16List* buddyGroupIDs,
   MirrorBuddyGroupList* buddyGroups)
{
   if( (retValGeneration == FhgfsOpsErr_SUCCESS) ||
      ( (retValGeneration == FhgfsOpsErr_INVAL) && doForce) )
   { // create the MirrorBuddyGroup
      if(!doDryrun)
      { // but only when it is not a dryrun
         UInt16ListIter iterIDs = buddyGroupIDs->begin();
         MirrorBuddyGroupListIter iterGroups = buddyGroups->begin();
         for( ; iterIDs != buddyGroupIDs->end(), iterGroups != buddyGroups->end(); iterIDs++,
            iterGroups++)
         {
            FhgfsOpsErr retValAddGroup = addGroup(mgmtNodes, iterGroups->firstTargetID,
               iterGroups->secondTargetID, *iterIDs);

            if(retValAddGroup != FhgfsOpsErr_SUCCESS)
               return false;
         }
      }
   }

   return true;
}

/**
 * Removes all targets from the TargetMapper which are part of a MirrorBuddyGroup
 *
 * @param localTargetMapper A TargetMapper with all targets, it should not be the TargetMapper
 *    from the app object, because this method removes some targets from this TargetMapper
 * @param oldBuddyGroupIDs MirrorBuddyGroupIDs from existing MirrorBuddyGroups
 * @param oldPrimaryTargetIDs PrimaryTargetIDs from existing MirrorBuddyGroups
 * @param oldSecondaryTargetIDs SecondaryTargetIDs from existing MirrorBuddyGroups
 * @return true if all targets successful removed from TargetMapper, false on error
 */
bool MirrorBuddyGroupCreator::removeTargetsFromExistingMirrorBuddyGroups(
   TargetMapper* localTargetMapper, UInt16List* oldBuddyGroupIDs, UInt16List* oldPrimaryTargetIDs,
   UInt16List* oldSecondaryTargetIDs)
{
   bool retVal = true;

   UInt16ListIter primaryID = oldPrimaryTargetIDs->begin();
   UInt16ListIter secondaryID = oldSecondaryTargetIDs->begin();
   for( ; primaryID != oldPrimaryTargetIDs->end() && secondaryID != oldSecondaryTargetIDs->end();
      primaryID++, secondaryID++)
   {
      retVal = retVal && localTargetMapper->unmapTarget(*primaryID);
      retVal = retVal && localTargetMapper->unmapTarget(*secondaryID);
   }

   return retVal;
}

/**
 * Find the TargetNumID of the next target which should be used for a MirrorBuddyGroup. A target
 * from the storage server with the most targets will be selected. It is possible to ignore the
 * targets of a storage server. The selected target is removed from the given TargetMapper.
 *
 * @param storageNodes NodeStore with all storage servers
 * @param localTargetMapper A TargetMapper with all targets which are not part of a
 *    MirrorBuddyGroupID, it should not be the TargetMapper from the app object
 * @param nodeNumIdToIgnore The NodeNumID to ignore in the search or 0 to disable the ignore feature
 * @return the TargetNumID to use or 0 if no target found
 */
uint16_t MirrorBuddyGroupCreator::findNextTarget(NodeStore* storageNodes,
   TargetMapper* localTargetMapper, uint16_t nodeNumIdToIgnore)
{
   uint16_t retVal = 0;

   size_t maxNumTargets = 0;

   Node* node = storageNodes->referenceFirstNode();
   while(node != NULL)
   {
      if (node->getNumID() == nodeNumIdToIgnore)
      {
         node = storageNodes->referenceNextNodeAndReleaseOld(node);
         continue;
      }

      UInt16List targetList;
      localTargetMapper->getTargetsByNode(node->getNumID(), targetList);

      if(targetList.size() > maxNumTargets)
      {
         maxNumTargets = targetList.size();
         retVal = targetList.front();
      }
      node = storageNodes->referenceNextNodeAndReleaseOld(node);
   }

   localTargetMapper->unmapTarget(retVal);

   return retVal;
}

/**
 * Generates a MirrorBuddyGroupID which is not used as TargetNumID or a MirrorBuddyGroupID.
 *
 * @return the new MirrorBuddyGroupID or 0 if a new MirrorBuddyGroupID is not available
 */
uint16_t MirrorBuddyGroupCreator::generateID(TargetMapper* targetMapper,
   UInt16List* usedMirrorBuddyGroups)
{
   uint16_t newGroupID = 1;

   // search if the selected ID is in use
   bool idFound = false;
   UInt16ListIter groupIter = usedMirrorBuddyGroups->begin();
   for( ; groupIter !=  usedMirrorBuddyGroups->end(); groupIter++)
   {
      if(*groupIter == newGroupID)
      {
         idFound = true;
         break;
      }
   }

   if ( idFound || (targetMapper->getNodeID(newGroupID) != 0) )
   {
      /*selected ID is in use already, so walk from there to find the next free ID. */
      for ( ;; )
      {
         newGroupID++;

         // check range... (avoid reserved value "0" as newNumID)
         if ( unlikely(!newGroupID || (newGroupID > MIRRORBUDDYGROUPMAPPER_MAX_GROUPIDS) ) )
         {
            newGroupID = 0;
            break;
         }

         // search if the selected ID is in use
         idFound = false;
         groupIter = usedMirrorBuddyGroups->begin();
         for( ; groupIter !=  usedMirrorBuddyGroups->end(); groupIter++)
         {
            if(*groupIter == newGroupID)
            {
               idFound = true;
               break;
            }
         }

         if ( (!idFound) && (targetMapper->getNodeID(newGroupID) == 0) )
            return newGroupID; // we found an ID that no other node uses
      }
   }

   return newGroupID;
}

/**
 * Check the size of the targets and prints a warning to the console if the size of all targets is
 * not equal.
 *
 * @param storageNodes NodeStore with all storage servers
 * @param mapper TargetMapper with all storage targets of the system
 * @return false if the targets have a different size or a error occurred,
 *    true if all targets have the same size
 */
bool MirrorBuddyGroupCreator::checkSizeOfTargets(NodeStoreServers* storageServer,
   TargetMapper* mapper)
{
   LogContext log = LogContext("MirrorBuddyGroupCreator (checkSizeOfTargets)");

   bool retVal = true;

   int64_t spaceValue = 0;

   // Retrieve the statStoragePath information from all storage servers
   Node* node = storageServer->referenceFirstNode();
   while( (node != NULL) && retVal)
   {
      UInt16List targets;
      mapper->getTargetsByNode(node->getNumID(), targets);

      // Retrieve the statStoragePath information from the storage server
      for(UInt16ListIter targetIter = targets.begin(); targetIter != targets.end(); targetIter++)
      {
         int64_t freeSpace;
         int64_t totalSpace;
         int64_t freeInodes;
         int64_t totalInodes;

         FhgfsOpsErr statRes = StorageTargetInfo::statStoragePath(node, *targetIter, &freeSpace,
            &totalSpace, &freeInodes, &totalInodes);
         if(statRes != FhgfsOpsErr_SUCCESS)
         {
            std::string logMessage("A error occurred during the connect to server: "
               + node->getNodeIDWithTypeStr() + " Error: " + FhgfsOpsErrTk::toErrString(statRes) );
            std::cerr << logMessage << std::endl;
            log.logErr(logMessage);

            storageServer->releaseNode(&node);
            return false;
         }

         if(spaceValue == 0) // check of the first target
            spaceValue = totalSpace;
         else
         if(spaceValue != totalSpace)
         {
            retVal = false;
            break;
         }
      }

      node = storageServer->referenceNextNodeAndReleaseOld(node);
   }

   // report a warning, because the size of all targets is not equal
   if(!retVal)
   {
      std::string logMessage("Target size differs. Automatic mode does not take this into account. "
         "It is recommended that all storage targets have the same size when using automatic mode."
         );
      std::cout << "[WARNING] " << logMessage << std::endl;
      log.log(Log_WARNING, logMessage);
   }

   return retVal;
}

/**
 * Checks which of the both targets is the best choice for the primary target. The storage server
 * with the lower primary target count is the best choice.
 *
 * @param targetMapper TargetMapper with all storage targets of the system
 * @param primaryUsed A map with NodeNumIDs to counter of primary targets
 * @param inOutPrimaryTargetID In/Out value for the primary TargetNumID
 * @param inOutSecondaryTargetID In/Out value for the secondary TargetNumID
 */
void MirrorBuddyGroupCreator::selectPrimaryTarget(TargetMapper* targetMapper,
   PrimaryTargetCounterMap* primaryUsed, uint16_t* inOutPrimaryTargetID,
   uint16_t* inOutSecondaryTargetID)
{
   uint16_t primaryServerNumID = targetMapper->getNodeID(*inOutPrimaryTargetID);
   uint16_t secondaryServerNumID = targetMapper->getNodeID(*inOutSecondaryTargetID);

   size_t primaryServerCounter = (*primaryUsed)[primaryServerNumID];
   size_t secondaryServerCounter = (*primaryUsed)[secondaryServerNumID];

   if(primaryServerCounter > secondaryServerCounter)
   {
      uint16_t tmpID = *inOutPrimaryTargetID;
      *inOutPrimaryTargetID = *inOutSecondaryTargetID;
      *inOutSecondaryTargetID = tmpID;

      (*primaryUsed)[secondaryServerNumID]++;
   }
   else
      (*primaryUsed)[primaryServerNumID]++;
}

/**
 * Generates MirrorBuddyGroups with the given targets, but do not create the MirrorBuddyGroups on
 * the management daemon
 *
 * @param storageServers NodeStore with all storage servers
 * @param systemTargetMapper TargetMapper with all storage targets of the system
 * @param outBuddyGroupIDs A list with all new selected MirrorBuddyGroupIDs
 * @param outBuddyGroups A list with all new selected MirrorBuddyGroups
 * @param localTargetMapper A TargetMapper with all targets which are not part of a
 *    MirrorBuddyGroupID, is should not be the TargetMapper from the app object
 * @param usedMirrorBuddyGroupIDs A list with used MirrorBuddyGroupIDs
 * @param useUniqueGroupIDs if true use unique MirrorBuddyGroupIDs. The ID is not used as storage
 * @return FhgfsOpsErr_SUCCESS when the selected MirrorBuddyGroups does not hurt any constraint,
 *    FhgfsOpsErr_INVAL at least one constraint is hurt, on error FhgfsOpsErr_...
 */
FhgfsOpsErr MirrorBuddyGroupCreator::generateMirrorBuddyGroups(NodeStoreServers* storageServers,
   TargetMapper* systemTargetMapper, UInt16List* outBuddyGroupIDs,
   MirrorBuddyGroupList* outBuddyGroups, TargetMapper* localTargetMapper,
   UInt16List* usedMirrorBuddyGroupIDs, bool useUniqueGroupIDs)
{
   LogContext log = LogContext("MirrorBuddyGroupCreator (generateMirrorBuddyGroups)");

   FhgfsOpsErr retVal = FhgfsOpsErr_SUCCESS;

   size_t numTargets = localTargetMapper->getSize();
   if(numTargets == 0)
   { // check if unused targets exists
      std::string logMessage("No targets without a BuddyMirrorGroup found. BuddyMirrorGroup is not "
         "changed.");
      std::cout << logMessage << std::endl;
      log.logErr(logMessage);

      return FhgfsOpsErr_INTERNAL;
   }

   if(numTargets % 2 != 0)
   { // check for even number of targets
      std::string logMessage("A odd number of targets detected. One target left without a "
         "BuddyMirrorGroup.");
      std::cout << "[WARNING] " << logMessage << std::endl;
      log.log(Log_WARNING, logMessage);

      retVal = FhgfsOpsErr_INVAL;
   }

   // check if all targets have the same size
   if(!checkSizeOfTargets(storageServers, systemTargetMapper) )
      retVal = FhgfsOpsErr_INVAL;

   // create a black list of MirrorBuddyGroupIDs, used MirrorBuddyGroupIDs + new MirrorBuddyGroupIDs
   UInt16List blackListGroupIDs;
   blackListGroupIDs.insert(blackListGroupIDs.begin(), usedMirrorBuddyGroupIDs->begin(),
      usedMirrorBuddyGroupIDs->end() );

   PrimaryTargetCounterMap primaryTargetCounter;

   while(numTargets > 1)
   { // requires at least two targets for a BuddyMirrorGroup
      uint16_t mirrorBuddyGroupID = 0;
      uint16_t primaryTarget = findNextTarget(storageServers, localTargetMapper, 0);
      uint16_t ignoreID = systemTargetMapper->getNodeID(primaryTarget);
      uint16_t secondaryTarget = findNextTarget(storageServers, localTargetMapper, ignoreID);

      if(secondaryTarget)
      { // second target on a different server found ==> good case
         selectPrimaryTarget(systemTargetMapper, &primaryTargetCounter, &primaryTarget,
            &secondaryTarget);
      }
      else
      { // all targets are located on the same server ==> bad case
         secondaryTarget = findNextTarget(storageServers, localTargetMapper, 0);
         if(!secondaryTarget)
         {
            std::string logMessage("No second target for BuddyMirrorGroup found.");
            std::cout << logMessage << std::endl;
            log.logErr(logMessage);

            return FhgfsOpsErr_INTERNAL;
         }
         std::string logMessage("Create BuddyMirrorGroup " +
            StringTk::uintToStr(mirrorBuddyGroupID) + " with targets " +
            StringTk::uintToStr(primaryTarget) + " and " + StringTk::uintToStr(secondaryTarget) +
            ", but both targets are located on the same server ");
         std::cout << "[WARNING] " << logMessage << std::endl;
         log.log(Log_WARNING, logMessage);

         retVal = FhgfsOpsErr_INVAL;
      }

      if(useUniqueGroupIDs)
      { // generate a MirrorBuddyGroupID, which is not a TargetNumID and not a MirrorBuddyGroupID
         mirrorBuddyGroupID = generateID(systemTargetMapper, &blackListGroupIDs);
      }
      else
      { // use the lower targetNumID of both targets
         if(primaryTarget < secondaryTarget)
            mirrorBuddyGroupID = primaryTarget;
         else
            mirrorBuddyGroupID = secondaryTarget;
      }

      outBuddyGroupIDs->push_back(mirrorBuddyGroupID);
      outBuddyGroups->push_back(MirrorBuddyGroup(primaryTarget, secondaryTarget) );
      blackListGroupIDs.push_back(mirrorBuddyGroupID);

      numTargets = localTargetMapper->getSize();
   }

   if(numTargets == 1)
   { // odd number of targets
      uint16_t lastTarget = findNextTarget(storageServers, localTargetMapper, 0);
      std::string logMessage("Storage target with targetNumID " + StringTk::uintToStr(lastTarget) +
         " unused, because no second target available.");
      std::cout << "[WARNING] " << logMessage << std::endl;
      log.log(Log_WARNING, logMessage);

      retVal = FhgfsOpsErr_INVAL;
   }

   return retVal;
}
